# C++ Notes

## 基础知识

### 注释

单行注释：//

多行注释：/*    */

### 变量

变量创建赋值语法：

```
数据类型 变量名 = 变量初始值
```

### 常量

宏常量(通常在文件上方定义，表示一个常量)

```
#define 常量名 常量值
```

**修饰的变量**(通常在变量定义前加关键字const，修饰该变量为常量，不可修改)

```
const 数据类型 变量名 = 变量值
```

### 标识符起名规则

+ 标识符只能由字母、数字、下划线组成

+ 第一个字符必须为字母或下划线

+ 标识符字母分大小写



## 数据类型

### 整形

短整型：short(2字节)   整形：int(4字节)

长整型：long(4字节)   长长整形：long long(8字节)

### sizeof关键字

作用：统计数据类型所占内存大小

语法：

```
sizeof(数据类型/变量)
```

### 浮点型(默认情况下只显示6位有效数字)

作用:表示小数

单精度:float(4字节)

双精度:double(8字节)

### 字符型(1字节)

作用：显示单个字符

语法：

```
char 变量名 = '变量值';
```

### 转义字符

\n：换行   \t：水平制表(整齐输出数据)   \\：代表字符"\"

### 字符串型

语法：

```
//用string要在头文件上写 #include<string>
string 变量名 = "字符串值"
char 变量名[] = "字符串值"
```

### 布尔类型(1字节)

定义：

```
bool 变量名 = true；   //显示为1
bool 变量名 = false；  //显示为0
```

### 数据的输入

语法：

```
cin >> 变量
```



## 运算符

### 算术运算符

```
% 取余:a1=10 a2=20 a1%a2=10 
++a 前置递增   a++ 后置递增
--a 前置递减   a-- 后置递减
//前置递增：先让变量加1在进行表达式运算
//后置递增：先进行表达式运算在让变量加1
```

### 赋值运算符

```
a+=2 
//本质为a=a+2
```

### 比较运算符

==:相等于   !=:不等于

### 逻辑运算符

！：非   &&：与   ||：或



## 程序流程结构

### 选择结构

#### if语句

```
//单行语句
if(条件)
{}

//多行语句
if(条件)
{}
else
{}

//多条件语句
if(条件)
{}
else if (条件)
{}
else
{}
```

#### 嵌套if语句

```
if(条件)
{
	if(条件)
	{}
	else if(条件)
	{}
	else
	{}
}
else
{}
```

#### 三目运算符

语法：

```
表达式1 ？ 表达式2 : 表达式3  
// 表达式1的值为真，执行表达式2，返回表达式2的结果
// 表达式1的值为假，执行表达式3，返回表达式3的结果
```

#### switch语句

语法：

```
switch(表达式)
{
	case 结果1: 执行语句;
	break;
	case 结果2: 执行语句;
	break;
	...
	default: 执行语句;
	break;
}
```

### 循环结构

#### while语句

语法：

```
while(循环条件){ 循环语句 }
```

#### do...while语句

语法：

```
do{ 循环语句 } while{ 循环语句 };
```

**注意:**while先判断，do...while先循环

#### for语句

语法：

```
for(起始表达式;条件表达式；末尾循环体) {循环语句；}
```

### 跳转语句

break语句(终止循环)

作用：用于switch、for、嵌套语句中来跳出循环

continue语句(跳过后面的代码，执行下一次循环)

goto语句(可以无条件跳转语句)   



## 数组

### 一维数组

特点：每个数据元素都是相同的数据类型

语法：

```
数据类型 数组名[] = {值1，值2，...};
```

一维数组名

```
// 统计整个数组在内存中的长度
seizeof(arr);
// 获取数组在内存中的首地址
cout<<arr<<ednl;
// 数组中一个元素的地址
&arr[下标]
```

#### 冒泡排序算法

排序总次数 = 元素个数-1

每轮对比次数 = 元素个数 - 排序轮数 -1 

### 二维数组

语法：

```
数据类型 数组名[行数][列数] = {{数据1，数据2}，{数据3，数据4}};
```

二维数组名(参考一维数组名)



## 函数

**函数定义语法：**

```
返回值类型 函数名 (形参)
{
	函数体语句
	return 表达式
}
```

**调用语法：**

```
函数名(参数)   // 没有参数可以不写
```

**值传递**

+ 如果形参发生改变，不会影响实参

+ 当不需要返回值时，可以在函数名前面加一个void

常见函数样式：

无参无返、有参无返、无参有返、有参有返

### 函数声明(提前告诉编译器函数的存在)

语法：

```
返回值类型 函数名(形参)
```

**函数的分文件编写**

1.创建后缀名为**.h**的头文件，在该文件写函数的声明

2.创建后缀名为**.cpp**的源文件，在该文件写函数的定义

```
// 在源文件中引用头文件
#include "文件名.h"
```



## 指针(相当于一个地址)

**指针定义语法：**

```
数据类型 * 变量名;
```

**指针使用：**

```
例子：
int a = 10;
int * p = &a; // 将指针p与变量a建立关系
*p; // 可以修改，读取a的值
```

占用内存大小：32位系统占4个，64位系统占8个

### 空指针(指针变量指向内存中编号为0的空间)

作用：初始化指针变量

**提示：**空指针指向的内存不可以访问

野指针(指向非法的内存空间)

### const修饰指针

```
// 常量指针：指针的指向可以改变，值不可以改变
const int * p = &a;

// 指针常量：指针的指向不可以改变，值可以改变
int * const p = &a;

//const既修饰指针又修饰常量:指针的指向和值都不可以改变
const int * const p = &a
```

### 指针和数组

```
// 利用指针遍历数组
int * p = arr;
for(int i = 0;i<10;i++)
{
	cout << p << endl;
	p2++;
}
```

### 指针和函数

地址传递：可以改变实参的值

```
 swap(&a,&b);
// 将a，b的地址传入函数中
```



## 结构体

语法：

```
struct 结构体名{结构体内容}; // 结构体定义

// 结构体创建
struct 结构体名 变量名 = {赋值，赋值...} 

struct 结构体名 变量名;
变量名.结构体成员变量 = 赋值;
```

### 结构体数组

```
struct 结构体名 数组名[元素个数] = { {},{},{}... }
数组名[第几个元素].结构体中的成员名 = 赋值 // 给结构体数组中的元素赋值
```

### 结构体指针

```
// 通过指针访问结构体变量中的数据的两种方法
指针名 -> 结构体中的成员名
*指针名.结构体中的成员名
```

### 结构体嵌套结构体

```
// 例子
struct erzi{
	int age;
};
struct jiazhang{
	int age;
	struct erzi b;
}
int main(){
	jiazhang a;
	a.age = 30 // 赋值30给jiazhang
	a.b.age = 11 // 赋值11给erzi
}
```

### 结构体做函数参数

```
// 例子

// 定义学生结构体
sturuct student 
{
	sring name;
}

// 创建函数值传递
void printStudent1(struct student s)
{
	cout << s.name;
}

// 创建函数地址传递，将函数中的形参改为指针时，会减少内存空间
void printStudent2(struct student * p)
{
	cout << p -> name;
}

int main(){
	struct student s; //创建结构体变量
	s.name = "张三";
	
	printStudent1(s); // 值传递
	printStudent2(&s); // 地址传递
}
```

### 结构体中const使用场景(防止误操作)

```
// 定义学生结构体
sturuct student 
{
	sring name;
}

// 创建函数地址传递，将函数中的形参改为指针时，会减少内存空间
void printStudent2(const student * p)
{
	// 这里当你试图修改name值时他会报错，所以在这里只能输出
}

int main(){
	struct student s; //创建结构体变量
	s.name = "张三";
	
	printStudent2(&s); // 地址传递
}
```



## 程序的内存模型

### 整体概览

C++程序在执行时，会将内存大致划分为4个区域

+ 代码区：存放函数体的二进制代码，由操作系统进行管理
+ 全局区：存放全局变量和静态变量及常量
+ 栈区：由编译器自动分配释放，存放函数的参数值、局部变量等
+ 堆区：由程序员分配和释放,若程序员不释放，程序结束时由操作系统回收



## 引用

作用：给变量起别名

语法：``数据类型 &别名 = 原名``

**本质：**是一个指针常量

 **注意事项：**

+ 引用必须初始化
+ 引用在初始化后，不可以改变

### 引用做函数参数

作用：函数传参时，可以用**引用**让形参修饰实参

优点：可以**简化**指针修改实参的操作**(不用指针)**

**值、地址、引用三者在传递之间的不同：**

```
 //值传递时，形参不会改变实参
 void mySwap1(int a, int b)
 {
 	int temp = a;
 	a = b;
 	b = temp;
 }
 
 //地址传递时，形参可以改变实参
 void mySwap2(int *a, int *b)
 {
 	int temp = *a;
 	*a = *b;
 	*b = temp;
 }
 
 //引用传递，形参可以改变实参
 void mySwap3(int &a, int &b)
 {
 	int temp = &a;
 	&a = &b;
 	&b = tmep;
 }
```

### 引用做函数返回值

作用：引用是可以作为函数的返回值的

**提示：**不要返回局部变量的引用

### 常量引用

作用：用来修饰形参，防止误操作

语法：``const 数据类型 &别名 = 原名``



## 函数提高

### 函数默认参数

语法：``返回值类型 函数名 (参数=默认值) {}``

**提示：**

+ 若某个位置已经有了默认参数，则从那个位置往后都必须有默认参数
+ 函数的声明和实现只能一个有默认参数

### 函数占位参数

作用：形参列表里可以有占位参数，用来占位，调用函数时必须填补该位置

语法：``返回值类型 函数名 (数据类型) {}``

**提示：**占位参数还可以有默认参数

### 函数重载

作用：函数名可以相同，提高复用性

函数重载满足条件：

+ 同一个作用域下
+ 函数名称相同
+ **函数参数类型**不同或者**个数**不同或者**顺序**不同

**提示：**函数的**返回值类型**不可以作为函数重载的条件

### 函数重载注意事项

+ 引用可以作为重载条件
+ 函数重载碰到函数默认参数会出现二义性



## 类和对象

理解：具有相同性质的对象，可以抽象称为类，而对象都有属性和行为(函数)

### 封装

#### 属性和行为

意义：

+ 将属性和行为作为一个整体，表现生活中的事物
+ 将属性和行为加以权限控制

语法：

```
class 类名
{
访问权限:
	属性
	行为(函数)
};

int main()
{
	//通过类，实例化创建具体对象
	类名 对象名; 
	
	//给对象的属性进行赋值
	对象名.属性 = 赋值;
}
```

```
//第二种赋值方法：在类中创建一个新函数
void set方法名(数据类型 变量名)
{
	属性名 = 变量名; 
}

int main()
{
	类名.set方法名(赋值)
}
```

**提示：**

+ 类中的属性和行为统一称为成员
+ 属性称为**成员属性**和**成员变量**
+ 行为称为**成员函数**和**成员方法**

#### 访问权限

意义：类在设计时，会将属性和行为放在不同的权限下，加以控制

三种访问权限：

+ public(公共权限)：成员在类内、类外都可以访问
+ protected(保护权限)：成员在类内可以访问，类外不可以访问,在**继承**中，儿子也**可以**访问父亲的**保护内容**
+ private(私有权限)：成员在类内可以访问，类外不可以访问，在**继承**中，儿子**不可以**访问父亲的**私有内容**

#### struct和class的区别

区别在于默认的**访问权限不同**：

+ struct默认权限为**公共**
+ class默认权限为**私有**

**提示：**两者都可以去写类，除了访问权限，没有本质区别

#### 成员属性设置为私有

优点：

+ 将所有成员属性设置为私有，可以自己控制读写权限
+ 对于写权限，我们可以检测数据的有效性

#### set和get方法

示例：

```
class Person
{
public:
	void setName(string name)
	{
		m_Name = name;
	}
	
	string getName()
	{
		return m_Name;
	}
	int getAge()
	{
		return m_Age;
	}
	void setIdol(stirng idol)
	{
		m_Idol = Idol
	}
private:
	string m_Name;
	int m_Age = 10;
	string m_Idol;
}

int main()
{
	Person p;
	p.setName = "张三"
	cout << p.getName; //在这里Name属性既有set也有get的方法，所以可以看到自己设置的“张三”姓名
	cout << p.getAge; //这里因为Age属性没有设置set方法，所以只能显示到在私有变量中设置的值
	p.setIdol = "小明"; //这里因为Idol属性没有设置get方法，所以无法读取，但无法显示出来
}
```

**提示：**

+ **set**方法控制的是**写**的权限
+ **get**方法控制的是**读**的权限



### 对象的初始化和清理

#### 构造函数和析构函数

作用：

+ 构造函数：作用于创建对象时为对象的成员属性赋值，析构函数由编译器自动调用，无需手动调用
+ 析构函数：作用于对象销毁前系统自动调用，执行一些清理工作

构造函数语法：``类名(){}``

**构造函数注意点：**

+ 没有返回值也不写**void**
+ 函数名称与类名相同
+ 构造函数可以有参数，因此**可以**发生重载
+ 程序在调用对象时会自动调用构造，无需手动调用，而且只会调用一次

析构函数语法：``~类名(){}``

**析构函数注意点：**

+ 没有返回值也不写**void**
+ 函数名称与类名相同，在名称前加上符号~
+ 析构函数不可以有参数，因此**不可以**发生重载
+ 程序在对象销毁前会自动调用析构，无需手动调用，而且只会调用一次

#### 构造函数的分类及调用

##### 函数类型

拷贝构造函数

```
Person(int a)
{
	age = a;
}

Person(const Person &p)
{
	//将传入的人身上的所有属性，拷贝到当前对象身上 
	age = p.age;
}
```

##### 调用方式

##### 括号法(常用)

```
Person p1; //默认构造
person p2(10); //有参构造
Person p3(p2); //拷贝构造
```

**提示：**调用默认构造函数时，不要加``()``因为这会让编译器认为是一个函数声明，而非创建对象

##### 显示法

```
Person p1; //默认构造
Person p2 = Person(10); //有参构造
Person p3 = Person(p2); //拷贝构造
```

**提示：**不要利用拷贝构造初始化匿名对象

##### 隐式转换法

```
Perosn p3; //默认构造
Person p4 = 10; //有参构造
Person p5 = p4; //拷贝构造
```

#### 拷贝构造函数调用时机

调用的三种情况：

+ 使用一个已经创建完毕的对象来初始化一个对象
+ 值传递的方式给函数参数传值 
+ 以值方式返回局部对象

#### 构造函数调用规则

+ 若用户定义有参构造函数，C++不会提供默认构造，但会提供默认拷贝构造
+ 若用户定义拷贝构造函数，C++不会再提供其他构造函数

#### 初始化列表

作用：初始化属性

语法：``构造函数(): 属性1(值1),属性2(值2)... {}``

#### 静态成员

语法：在成员变量和成员函数前加上关键字**static**

##### 静态成员变量

+ 所有对象共享同一份数据
+ 在编译阶段分配内存
+ 类内声明，类外初始化

###### 访问方式

+ 通过对象进行访问
+ 通过类名进行访问 ``类名::变量名``

##### 静态成员函数

+ 所有对象共享一个函数
+ 静态成员函数只能访问静态成员变量

**提示：**访问方式与静态成员变量相同



### this指针

作用：

+ 解决名称冲突
+ 返回对象本身用***this**

使用：

+ 当形参和成员变量同名时，可用this指针来区分
+ 在类的非静态成员函数中返回对象本身，可使用``renturn *this``

语法：``this->变量名 = 变量名``

提示：this指针指向被调用的成员函数所属的对象

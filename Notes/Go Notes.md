# Go Notes



## 走进Golang

### dos命令及什么是API

dos命令：就是通过cmd进入的“控制命令台”

API：指的是应用程序编程接口，通俗来讲就是**使用说明书**

#### 具体的dos命令

+ 切换盘符：``c:``
+ 显示详细信息：``dir``
+ 进入目录：``cd 文件夹名``
+ 退回上一级：``cd..``
+ 清屏命令：``cls``
+ 切换历史命令：``上下箭头``
+ 创建/删除目录：``md/rd 文件夹名``
+ 删除文件：``del 文件名``



## 输出格式

格式化输出举例：``fmt.Printf("%c,%c,%c",变量1,变量2，变量3)``

+ 万能占位符``%v``:根据值的类型，进行合适的输出

+ ``%c``:用于输出单个字符

+ ``%d``:用于输出整数值

- `%f`: 用于输出浮点数。
- `%s`: 用于输出字符串。
- `%t`: 用于输出布尔值。
- `%p`: 用于输出指针值。
- ``%T``:用于输出类型
- ``%x``:用于输出十六进制



## 变量与数据类型



### 变量

定义变量语法：``var 变量名 数据类型 = 值``

长度：``len(变量名)``

下标：``变量名[a][b]``若是一维数组可以不写后面的

**常用的定义语法**

```
var(
	a = 值1
	b = 值2
)
```

#### 变量定义方式

省略var：``变量名 := 值``

不写变量类型，根据后面值自行判定：``var 变量名 = 值``

**多变量声明**

+ ``var x,y,z = 值1,值2,值3``
+ ``a,b := 值1,值2``

#### 变量的注意事项

+ 定义在函数外的变量为全局变量，函数里叫局部变量
+ 变量重复定义会报错
+ 定义的变量或者import的包如果没有使用，代码则会报错
+ 定义的数据类型和所赋值的类型不同会报错



### 数据类型

查看数据类型：``fmt.Printf("%T",变量名)``

查看所占字节：``fmt.Println(unsafe.Sizeof(变量名))``

#### 分类

有符号整数型：int、int16、int32、int64

无符号整数型**(只能表示正数)**：unit8、unit16、unit32、unit64

浮点型：float32、float64

布尔型声明：``var 变量1 bool = true``

#### 转义字符

+ 换行：``\n``
+ 退格：``\b``
+ 光标回到开头，后续输入替换原有字符：``\r``
+ 制表符：``\t``
+ 显示单/双引号在前面加``\``

#### 字符串

当你使用字符串时，里面有许多特殊符号时,可以这样写``var 变量名 string = '值'``

当你拼接一个字符串过长时，你按回车键将其换行，要注意将**+号**留在上一行的最后

#### 类型转换(在这里面，b都为要被转换的变量)

+ 浮点型和整形之间转换：``var a float64 = float64(b)``

​		注意这里转换的只是**b的值**，b还是之前自己的类型

​		注意当转换后的值若**超出**当前类型的大小范围，会造成**数值溢出**

+ **其它类型往字符串类型转换**

  整型转字符串：``var a string = fmt.Sprintf("%d",b)``

  浮点型转字符串：``var a string = fmt.Sprintf("%f",b)``

  布尔型转字符串：``var a string = fmt.Sprintf("%t",b)``

  字符型转字符串：``var a string = fmt.Sprintf("%c",b)``

+ **字符串类型往其它类型转换**

  字符串转布尔型：``a,_ = strconv.ParseBool(b)``

  字符串转整形：``a,_ = strconv.ParseInt(b,10,64)``这里表示将b转成10进制且为int64型

  字符串转浮点型：``a,_ = strconv.ParseFloat(b,64)``

​	   注意字符串转其它类型时，要确保能转成有效的数据类型，否则输出为默认值

​	   **注意引入strconv包**



### 指针-复杂数据类型(指针就是内存地址)

查看变量的地址：``fmt.Println(&变量名)``

定义指针变量：``var 指针名 *int = &变量名``

根据指针输出值：``fmt.Printf(*指针名)``

#### 使用细节

+ 可以通过指针改变指向值	

```
var a int = 10
var ptr *int = &a
*ptr = 20 //此时a的值变为20
```

+ 指针变量接受的一定是地址值
+ 指针变量的地址不可以不匹配

#### 符号讲解

+ &：返回变量的存储地址
+ *：取指针变量对应的数值



### 标识符(变量、方法的名字)

可以由**数字、字母、下划线_**组成

不可以以数字开头、区分大小写、不能含空格

**下划线_**不可以单独作为标识符使用

#### 起名规则

+ 包名：package名字和文件名保持一致，和标注库不要冲突
+ 变量名、函数名、常量名采用驼峰法命名
+ 若变量名、函数名、常量名首字母**大写**，则**其它包可以访问**，首字母**小写**则**只能在本包使用**



## 运算符

### 逻辑运算符

+ 且：``&&``
+ 或：``||``
+ 非：``!``

**提示**：为了提高运算优先级，可以加``()``

### 获取用户终端输入

语法：``fmt.Scanln(&变量名)``

**注意点**

+ 传入的一定要是**地址**，否则接受不到
+ 用户输出的值必须与变量的数据类型**相同**，否则接收不到



## 流程控制

### 分支结构

#### if分支

##### 单分支

语法

```
if 条件表达式 {
	逻辑代码
}

//可以将变量定义跟条件表达式写在一起
if a := 10;a < 10 {
	逻辑代码
}
```

##### 双分支

语法

```
if 条件表达式 {
	逻辑代码
} else {
	逻辑代码
}
```

这里要注意else一定要写在if最后**一个花括号后面**，否则运行不了

##### 多分支

语法

```
if 条件表达式 {
	逻辑代码
} else if 条件表达式{
	逻辑代码
} else {
	逻辑代码
}
```



#### switch分支

语法

```
//switch后面是一个表达式，表达式的结果依次跟case进行比较，满足结果就执行当前的语句
switch 表达式{
	case a,b,...:
		语句
	case x,y,...:
		语句
	//当其他case都不满足时，执行default
	default:
		语句
}
```

**注意点**

+ switch后面是一个表达式，即常量、变量、有返回值的函数都可以
+ case后面的各个值的数据类型，必须和switch的表达式数据类型一致	

```
//以下是一个错误案例，因为a与b的数据类型不同，所以运行错误
var a int32 = 5
var b int64 = 9
switch a {
	case b:
}
```

+ case后面可以写多个值，用逗号隔开
+ 要想让switch穿透下面一个语句，可以在语句下面加一个``fallthrough``



### 循环结构

#### for循环

语法

```
for 初始值;条件表达式;迭代因子 {
	循环体;
}
```

注意这里的**初始值**要写成``a := 10``这种形式

#### for range(可以遍历数组、切片、字符串、map及通道)

语法

```
for a,b := range c {
	...
}

//下面是一个遍历字符串的例子
//这里的意思是对c进行遍历，每个索引值被a接收，每个索引的具体值被b接收
for a , b := range c {
	fmt.Printf("索引为%d,具体值为%c",a,b)
}
```

#### for range和for的区别

for range可以遍历中文字符，for则不可以



### 关键字

#### break(直接结束循环)

+ 注意``break``只是**停止自身存在**的循环，后续的代码仍然正常运行
+ 可以加入标签来选择你想要停止的循环,若你定义了标签但**未使用**，则会**报错**

```
//下面是给外侧循环设置一个标签，然后通过break与标签联动实现循环停止
lable:
for a := 1; a <= 5; a++ {
	for b := 2; b <= 4; b++ {
		fmt.Printf("%v,%v",a,b)
		if a == 2 && b ==2 {
			break labe1
		}
	}
}
```

#### continue(跳过本次循环，继续下一次循环)

代码演示

```
//下面是给外侧循环设置一个标签，然后通过continue与标签联动实现循环跳过
lable:
for a := 1; a <= 5; a++ {
	for b := 2; b <= 4; b++ {
		if a == 2 && b ==2 {
			continue labe1 //在这里continue会跳过这里的输出(2,2)循环，直接执行下一次
		}
		fmt.Printf("%v,%v",a,b)
	}
}
```

#### return(结束当前函数/方法，后续代码将不会被执行)

代码演示

```
//在下面的代码中当a==14后将不会有任何代码执行
for a := 1; a <= 100; a++ {
	fmt.Println("1")
	if a == 14 {
		return
	}
	fmt.Println("2")
}
```



#### goto(不建议使用：无条件转移到程序中指定的行)

+ 一般与标签、条件结构配合使用

  ```
  //下面的代码中"2"将不会被输出
  fmt.Println("2")
  if 1 == 1{
  	goto label
  }
  fmt.Println("2")
  label:
  fmt.Println("3")
  ```



## 函数(可以将函数看为某个功能，使用时直接调用即可)

语法

```
//函数定义
func 函数名 (形参列表) (返回值类型) {
	执行语句
	return 返回值列表
}

//函数调用
//用一个变量去接收返回值
a := 函数名(值1,值2)
//没有返回值直接调用
函数名(值1,值2)
```



### 细节

#### 函数名

+ 首字母**大写**则函数可以被本包和其它包使用**(类似public)**
+ 首字母**小写**则只能被本包文件使用**(类似private)**

#### 形参列表和返回值类型(都可以是一个、n个、0个)

代码演示

```
//下面是计算a与b的和、差
func cal (a int,b int) (int,int) {
	var c int = 0
	c += a
	c += b
	var d int = a - b
	return c,d
}

//最后在主函数利用两个变量接收返回值
sum1,sum2 := cal(值1，值2)
//如果有返回值不想接收，可以用_来替代,这将会忽略后面的值
sum1,_ := cal(值1，值2)
```

#### 可变参数(参数数量可以不设定，随时改变)

代码演示

```
func parameter (args...int){ //可传入多个int类型数据
	for i := 0; i < len(args); i++ { //遍历可变参数
		fmt.Println(args[i])
	}
}
func main(){
	parameter(1,2,3)
}
```

#### 地址传递改变值

代码演示

```
func addres(num *int) {
	*num = 100
}
func main(){
	num = 10
	addres(&num)
	fmt.Println(num) //输出的num的值为100
}
```

#### 自定义数据类型(相当于起了个别名)

语法：``type 数据类型名 数据类型``


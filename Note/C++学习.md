# C++学习

## 1.基础知识

### 1.注释

单行注释：//

多行注释：/*    */

### 2.变量

变量创建语法

```
数据类型 变量名 = 变量初始值
```

### 3.常量

宏常量(通常在文件上方定义，表示一个常量)

```
#define 常量名 常量值
```

修饰的变量(通常在变量定义前加关键字const，修饰该变量为常量，不可修改)

```
const 数据类型 变量名 = 变量值
```

### 4.标识符起名规则

(1)标识符只能由字母、数字、下划线组成

(2)第一个字符必须为字母或下划线

(3)标识符字母分大小写



## 2.数据类型

### 1.整形

短整型：short(2字节)   整形：int(4字节)

长整型：long(4字节)   长长整形：long long(8字节)

### 2.sizeof关键字

作用：统计数据类型所占内存大小

语法

```
sizeof(数据类型/变量)
```

### 2.浮点型(默认情况下只显示6位有效数字)

作用:表示小数

单精度:float(4字节)

双精度:double(8字节)

### 3.字符型(1字节)

作用：显示单个字符

语法

```
char ch = '变量值';
```

### 4.转义字符

\n：换行   \t：水平制表(整齐输出数据)   \\：代表字符"\"

### 5.字符串型

语法

```
//用string要在头文件上写 #include<string>
string 变量名 = "字符串值"
char 变量名[] = "字符串值"
```

### 6.布尔类型(1字节)

```
bool 变量名 = true；   //显示为1
bool 变量名 = false；  //显示为0
```

### 7.数据的输入

语法

```
cin >> 变量
```



## 3.运算符

### 1.算术运算符

```
% 取余:a1=10 a2=20 a1%a2=10 
++a 前置递增   a++ 后置递增
--a 前置递减   a-- 后置递减
//前置递增：先让变量加1在进行表达式运算
//后置递增：先进行表达式运算在让变量加1
```

### 2.赋值运算符

```
a+=2 
//本质为a=a+2
```

### 3.比较运算符

==:相等于   !=:不等于

### 4.逻辑运算符

！：非   &&：与   ||：或



## 4.程序流程结构

### 1.选择结构

**if语句**

```
//单行语句
if(条件)
{}

//多行语句
if(条件)
{}
else
{}

//多条件语句
if(条件)
{}
else if (条件)
{}
else
{}
```

**嵌套if语句**

```
if(条件)
{
	if(条件)
	{}
	else if(条件)
	{}
	else
	{}
}
else
{}
```

**三目运算符**

语法

```
表达式1 ？ 表达式2 : 表达式3  
// 表达式1的值为真，执行表达式2，返回表达式2的结果
// 表达式1的值为假，执行表达式3，返回表达式3的结果
```

**switch语句**

语法

```
switch(表达式)
{
	case 结果1: 执行语句;
	break;
	case 结果2: 执行语句;
	break;
	...
	default: 执行语句;
	break;
}
```

### 2.循环结构

**while语句**

语法

```
while(循环条件){ 循环语句 }
```

**do...while语句**

```
do{ 循环语句 } while{ 循环语句 };
```

**注意:**while先判断，do...while先循环

**for语句**

语法

```
for(起始表达式;条件表达式；末尾循环体) {循环语句；}
```

### 3.跳转语句

**break语句**(终止循环)

作用：用于switch、for、嵌套语句中来跳出循环

**continue语句**(跳过后面的代码，执行下一次循环)

**goto语句**(可以无条件跳转语句)   // 尽量不使用



## 5.数组

### 1.一维数组

特点：每个数据元素都是相同的数据类型

语法

```
数据类型 数组名[] = {值1，值2，...};
```

**一维数组名**

```
// 统计整个数组在内存中的长度
seizeof(arr);
// 获取数组在内存中的首地址
cout<<arr<<ednl;
// 数组中一个元素的地址
&arr[下标]
```

**冒泡排序算法**

排序总次数 = 元素个数-1

每轮对比次数 = 元素个数 - 排序轮数 -1 

### 2.二维数组

语法

```
数据类型 数组名[行数][列数] = {{数据1，数据2}，{数据3，数据4}};
```

**二维数组名**(参考一维数组名)



## 6.函数

**函数定义语法**

```
返回值类型 函数名 (形参)
{
	函数体语句
	return 表达式
}
```

**调用语法**

```
函数名(参数)   // 没有参数可以不写
```

**值传递**

1.如果形参发生改变，不会影响实参

2.当不需要返回值时，可以在函数名前面加一个void

**常见函数样式**

无参无返、有参无返、无参有返、有参有返

**函数声明**(提前告诉编译器函数的存在)

语法

```
返回值类型 函数名(形参)
```

**函数的分文件编写**

1.创建后缀名为**.h**的头文件，在该文件写函数的声明

2.创建后缀名为**.cpp**的源文件，在该文件写函数的定义

```
// 在源文件中引用头文件
#include "文件名.h"
```



## 7.指针(相当于一个地址)

**指针定义语法**

```
数据类型 * 变量名;
```

**指针使用**

```
例子：
int a = 10;
int * p = &a; // 将指针p与变量a建立关系
*p; // 可以修改，读取a的值
```

**占用内存大小**：32位系统占4个，64位系统占8个

**空指针**(指针变量指向内存中编号为0的空间)

作用：初始化指针变量

注意：空指针指向的内存不可以访问

**野指针**(指向非法的内存空间)

**const修饰指针**

```
// 常量指针：指针的指向可以改变，值不可以改变
const int * p = &a;

// 指针常量：指针的指向不可以改变，值可以改变
int * const p = &a;

//const既修饰指针又修饰常量:指针的指向和值都不可以改变
const int * const p = &a
```

**指针和数组**

```
// 利用数组遍历数组
int * p = arr;
for(int i = 0;i<10;i++)
{
	cout << p << endl;
	p2++
}
```

**指针和函数**

地址传递：可以改变实参的值

```
 swap(&a,&b);
// 将a，b的地址传入函数中
```



## 8.结构体

语法

```
struct 结构体名{结构体内容}; // 结构体定义

// 结构体创建
struct 结构体名 变量名 = {赋值，赋值...} 

struct 结构体名 变量名;
变量名.结构体成员变量 = 赋值;
```

**结构体数组**

语法

```
struct 结构体名 数组名[元素个数] = { {},{},{}... }
数组名[第几个元素].结构体中的成员名 = 赋值 // 给结构体数组中的元素赋值
```

**结构体指针**

语法

```
// 通过指针访问结构体变量中的数据的两种方法
指针名 -> 结构体中的成员名
*指针名.结构体中的成员名
```

**结构体嵌套结构体**

语法

```
// 例子
struct erzi{
	int age;
};
struct jiazhang{
	int age;
	struct erzi b;
}
int main(){
	jiazhang a;
	a.age = 30 // 赋值30给jiazhang
	a.b.age = 11 // 赋值11给erzi
}
```

**结构体做函数参数**

```
// 例子

// 定义学生结构体
sturuct student 
{
	sring name;
}

// 创建函数值传递
void printStudent1(struct student s)
{
	cout << s.name;
}

// 创建函数地址传递，将函数中的形参改为指针时，会减少内存空间
void printStudent2(struct student * p)
{
	cout << p -> name;
}

int main(){
	struct student s; //创建结构体变量
	s.name = "张三";
	
	printStudent1(s); // 值传递
	printStudent2(&s); // 地址传递
}
```

**结构体中const使用场景(防止误操作)**

```
// 定义学生结构体
sturuct student 
{
	sring name;
}

// 创建函数地址传递，将函数中的形参改为指针时，会减少内存空间
void printStudent2(const student * p)
{
	// 这里当你试图修改name值时他会报错，所以在这里只能输出
}

int main(){
	struct student s; //创建结构体变量
	s.name = "张三";
	
	printStudent2(&s); // 地址传递
}
```

